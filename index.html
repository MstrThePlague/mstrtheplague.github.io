<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mysterious Interactive Experience with Matter.js</title>
  <!-- Include Matter.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: block;
    }
    #overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255,255,255,0.7);
      font-family: 'Courier New', Courier, monospace;
      text-align: center;
      pointer-events: none;
      white-space: pre-wrap;
      font-size: 2em;
      opacity: 0;
      transition: opacity 5s ease-in-out;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="overlay"></div>
  <script>
    // ----- Ambient Soundscape (unchanged) -----
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    let masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.2;
    masterGain.connect(audioCtx.destination);
  
    let ambientAnalyser = null;
    let frequencyData = null;
  
    function createAmbientNoise() {
      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        output[i] = Math.random() * 2 - 1;
      }
      const noiseSource = audioCtx.createBufferSource();
      noiseSource.buffer = noiseBuffer;
      noiseSource.loop = true;
  
      // Lower frequencies via lowpass filter
      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 200;
  
      noiseSource.connect(filter);
  
      ambientAnalyser = audioCtx.createAnalyser();
      ambientAnalyser.fftSize = 256;
      frequencyData = new Uint8Array(ambientAnalyser.frequencyBinCount);
  
      filter.connect(ambientAnalyser);
      ambientAnalyser.connect(masterGain);
  
      return noiseSource;
    }
  
    let ambientStarted = false;
    function startAmbientSound() {
      if (!ambientStarted) {
        const noise = createAmbientNoise();
        noise.start(0);
        ambientStarted = true;
      }
    }
  
    window.addEventListener('click', startAmbientSound);
    window.addEventListener('touchstart', startAmbientSound);
  
    // ----- Canvas Setup -----
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
  
    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }
  
    let mouse = { x: null, y: null, vx: 0, vy: 0 };
    let lastMouse = { x: null, y: null };
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
  
    // ----- Matter.js Engine Setup -----
    const Engine = Matter.Engine,
          World  = Matter.World,
          Bodies = Matter.Bodies,
          Runner = Matter.Runner;
  
    const engine = Engine.create();
    engine.world.gravity.y = 0; // no gravity for a floating starfield
  
    const runner = Runner.create();
    Runner.run(runner, engine);
  
    // We'll store our cube bodies here.
    let cubeBodies = [];
    let desiredCount = Math.floor((width * height) / 6000);
  
    // Create boundaries (walls) so the bodies bounce within the canvas.
    function createWalls() {
      if (window.walls) {
        World.remove(engine.world, window.walls);
      }
      window.walls = [
        Bodies.rectangle(width/2, -25, width, 50, { isStatic: true }),
        Bodies.rectangle(width/2, height+25, width, 50, { isStatic: true }),
        Bodies.rectangle(-25, height/2, 50, height, { isStatic: true }),
        Bodies.rectangle(width+25, height/2, 50, height, { isStatic: true })
      ];
      World.add(engine.world, window.walls);
    }
  
    // Create cube bodies â€“ we use Matter.js circle bodies (for simplicity)
    // and attach extra properties for our custom 3D render.
    function createCubeBodies() {
      // Remove any existing bodies (except walls)
      if (cubeBodies.length > 0) {
        World.remove(engine.world, cubeBodies);
      }
      cubeBodies = [];
      desiredCount = Math.floor((width * height) / 6000);
      for (let i = 0; i < desiredCount; i++) {
        let x = rand(0, width);
        let y = rand(0, height);
        let r = rand(2, 4); // Matter body radius (used only for physics)
        // Create a circular body for physics simulation.
        let body = Bodies.circle(x, y, r, { frictionAir: 0.02, restitution: 0.8 });
        // We'll render as a 3D cube: store a cubeSize (in pixels)
        body.cubeSize = r * 4; // adjust as desired
        // Initialize a custom 3D rotation (in radians)
        body.renderData = { rotation: Math.random() * Math.PI * 2 };
        cubeBodies.push(body);
      }
      World.add(engine.world, cubeBodies);
    }
  
    createWalls();
    createCubeBodies();
  
    // ----- Wireframe Cube Rendering (3D Projection) -----
    // Simple perspective projection: d is the "distance" constant.
    function projectPoint(x, y, z, d) {
      let factor = d / (d + z);
      return { x: x * factor, y: y * factor };
    }
  
    // Rotate a 3D point about Y axis
    function rotateY(point, theta) {
      let cos = Math.cos(theta), sin = Math.sin(theta);
      return { x: point.x * cos + point.z * sin, y: point.y, z: -point.x * sin + point.z * cos };
    }
    // Rotate a 3D point about X axis
    function rotateX(point, theta) {
      let cos = Math.cos(theta), sin = Math.sin(theta);
      return { x: point.x, y: point.y * cos - point.z * sin, z: point.y * sin + point.z * cos };
    }
  
    // Draw a wireframe cube for a given body.
    // The cube is centered at (0,0,0) in its local space and then rotated and projected.
    function drawWireframeCube(ctx, body) {
      const size = body.cubeSize; // total cube width
      const half = size / 2;
      // Define cube vertices in local coordinates.
      let vertices = [
        {x: -half, y: -half, z: -half},
        {x:  half, y: -half, z: -half},
        {x:  half, y:  half, z: -half},
        {x: -half, y:  half, z: -half},
        {x: -half, y: -half, z:  half},
        {x:  half, y: -half, z:  half},
        {x:  half, y:  half, z:  half},
        {x: -half, y:  half, z:  half}
      ];
      // Use the body's custom rotation value.
      let theta = body.renderData.rotation;
      // For a simple effect, apply the same rotation around Y and then X.
      let transformed = vertices.map(v => {
        let rY = rotateY(v, theta);
        let rX = rotateX(rY, theta * 0.5);
        return rX;
      });
  
      // Perspective projection: use d (distance) = 200
      const d = 200;
      let projected = transformed.map(v => projectPoint(v.x, v.y, v.z, d));
  
      // Offset projected points by the body's physics position.
      const pos = body.position;
      projected = projected.map(v => ({ x: v.x + pos.x, y: v.y + pos.y }));
  
      // Define edges (pairs of vertex indices) for the cube.
      const edges = [
        [0,1],[1,2],[2,3],[3,0], // back face
        [4,5],[5,6],[6,7],[7,4], // front face
        [0,4],[1,5],[2,6],[3,7]  // connecting edges
      ];
  
      ctx.strokeStyle = "rgba(224,202,60,0.8)";
      ctx.lineWidth = 1;
      edges.forEach(pair => {
        const v1 = projected[pair[0]];
        const v2 = projected[pair[1]];
        ctx.beginPath();
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.stroke();
      });
    }
  
    // ----- Glitching Overlay for Cryptic Phrases (unchanged from previous) -----
    const messages = [
      "The night whispers secrets...",
      "Echoes of forgotten dreams...",
      "Shadows dance in silent riddles...",
      "You are watched by unseen eyes...",
      "The abstract unveils hidden truths...",
      "Mysteries lie beyond the veil...",
      "Time unravels in silent echoes...",
      "The void hums in ancient tones...",
      "Lost voices stir the abyss...",
      "A distant echo of what once was...",
      "In the stillness, the unknown stirs...",
      "Fragile whispers weave the fabric of reality..."
    ];
    let currentMessage = "";
  
    const glitchChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[]{};:,.<>/?\\|";
  
    function randomGlitchChar() {
      return glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));
    }
  
    function getGlitchedText(target, revealFraction) {
      let result = "";
      for (let i = 0; i < target.length; i++) {
        result += Math.random() < revealFraction ? target.charAt(i) : randomGlitchChar();
      }
      return result;
    }
  
    function glitchAndShowMessage(message) {
      const glitchDuration = 1500;
      const startTime = Date.now();
      const interval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        let revealFraction = Math.min(elapsed / glitchDuration, 1);
        overlay.textContent = getGlitchedText(message, revealFraction);
        if (revealFraction >= 1) {
          clearInterval(interval);
        }
      }, 100);
    }
  
    function updateOverlayMessage() {
      const newMessage = messages[Math.floor(Math.random() * messages.length)];
      if (newMessage !== currentMessage) {
        currentMessage = newMessage;
        overlay.style.opacity = isMobile ? 0.1 : 0.05;
        glitchAndShowMessage(currentMessage);
        setTimeout(() => { overlay.style.opacity = isMobile ? 0.5 : 0.3; }, 100);
        setTimeout(() => { overlay.style.opacity = 0; }, 8000);
      }
    }
    setInterval(updateOverlayMessage, 15000);
    updateOverlayMessage();
    // ----- End Glitch Overlay -----
  
    // ----- Background Gradient (based on #3A405A) with Parallax -----
    function drawBackground() {
      let offsetX = 0, offsetY = 0;
      if (mouse.x !== null && mouse.y !== null) {
        offsetX = (mouse.x - width / 2) * 0.05;
        offsetY = (mouse.y - height / 2) * 0.05;
      }
      const colorStart = "#3A405A";
      const colorEnd = "#2A2D45";
      const gradient = ctx.createLinearGradient(0 + offsetX, 0 + offsetY, width + offsetX, height + offsetY);
      gradient.addColorStop(0, colorStart);
      gradient.addColorStop(1, colorEnd);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }
  
    // ----- Main Animation Loop -----
    function animate() {
      // Draw semi-transparent overlay for trails.
      ctx.fillStyle = "rgba(0,0,0,0.1)";
      ctx.fillRect(0, 0, width, height);
  
      // Draw background (with parallax) beneath everything.
      ctx.globalCompositeOperation = "destination-over";
      drawBackground();
      ctx.globalCompositeOperation = "source-over";
  
      // Get audio data for potential reactivity (if desired)
      let bassFactor = 0;
      if (ambientAnalyser) {
        ambientAnalyser.getByteFrequencyData(frequencyData);
        let bassSum = 0;
        const count = 10;
        for (let i = 0; i < count; i++) {
          bassSum += frequencyData[i];
        }
        bassFactor = bassSum / (count * 256);
      }
  
      // For each cube body, update its custom rotation and draw as a wireframe cube.
      cubeBodies.forEach(body => {
        // Slowly increment the custom rotation.
        body.renderData.rotation += 0.02;
        drawWireframeCube(ctx, body);
      });
  
      requestAnimationFrame(animate);
    }
    animate();
  
    // ----- Mouse and Touch Interactivity for Parallax -----
    function updateMouse(e) {
      if (lastMouse.x !== null && lastMouse.y !== null) {
        mouse.vx = e.clientX - lastMouse.x;
        mouse.vy = e.clientY - lastMouse.y;
      }
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      lastMouse.x = e.clientX;
      lastMouse.y = e.clientY;
    }
    if (!isMobile) {
      window.addEventListener('mousemove', updateMouse);
    } else {
      window.addEventListener('touchmove', (e) => {
        if (e.touches && e.touches.length > 0) {
          const touch = e.touches[0];
          mouse.x = touch.clientX;
          mouse.y = touch.clientY;
        }
      }, { passive: true });
    }
  
    // ----- Handle Window Resize -----
    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      // Recreate walls and cube bodies based on new size.
      createWalls();
      createCubeBodies();
    });
  </script>
</body>
</html>